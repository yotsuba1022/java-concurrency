# Atomic Variables

* The intrinsic locks that are associated with object monitors have historically suffered
  from poor performance. Although performance has improved, they still present a
  bottleneck when creating web servers and other applications that require high scalability
  and performance in the presence of significant thread contention.

* A lot of research has gone into creating nonblocking algorithms that can radically
  improve performance in synchronization contexts. These algorithms offer increased
  scalability because threads don't block when multiple threads contend for the same data.
  Also, threads donâ€™t suffer from deadlock and other liveness problems.

* Java 5 provided the ability to create efficient nonblocking algorithms by introducing
  the java.util.concurrent.atomic package. According to this package's JDK
  documentation, java.util.concurrent.atomic provides a small toolkit of classes that
  support lock-free, thread-safe operations on single variables.

* The classes in the java.util.concurrent.atomic package extend the notion of
  volatile values, fields, and array elements to those that also provide an atomic
  conditional update so that external synchronization isn't required. In other words, you
  get mutual exclusion along with the memory semantics associated with volatile
  variables without external synchronization.

* Some of the classes located in java.util.concurrent.atomic are described here:
    * AtomicBoolean
    * AtomicInteger
    * AtomicIntegerArray
    * AtomicLong
    * AtomicLongArray
    * AtomicReference
    * AtomicReferenceArray

* Atomic variables are used to implement:
    * counters
    * sequence generators (such as java.util.concurrent.ThreadLocalRandom)
    * other constructs that require mutual exclusion without performance problems under high thread contention
