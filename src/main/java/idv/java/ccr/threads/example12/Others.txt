Other related topics:

Here we will discuss some loose ends related to threads that didn't fit into the previous examples.
First, let's remind ourselves of what an atomic action means. As we've seen, when a thread is running,
it can be suspended when it's in the middle of doing something.

For example, if a thread calls the System.out.println() method, it can be suspended in the middle of executing the method.
It may have evaluated the argument that's being passed, but it's suspended before it can print the result.
Or it may be partway through evaluating the argument when it's suspended. Essentially, System.out.println() isn't an atomic action.

An atomic action can't be suspended in the middle of being executed. It either completes, or it doesn't happen at all.
Once a thread starts to run an atomic action, we can be confident that it won't be suspended until it has completed the action.

In Java, we mentioned that the following operations are atomic:

1. Reading and writing reference variables. For example, the statement myObject1 = myObject2 would be atomic.
   A thread can’t be suspended in the middle of executing this statement.

2. Reading and writing primitive variables, except those of type long and double. The JVM may require two operations
   to read and write longs and doubles, and a thread can be suspended between each operation. For example,
   a thread can’t be suspended in the middle of executing myInt = 10. But it can be suspended in the middle of
   executing myDouble = 1.234.

3. Reading and writing all variables declared volatile.

Now take a look at the third item: volatile. You may think that since we don’t have to worry about thread interference
with atomic actions, that we don’t need to synchronize them, but that isn’t true. Because of the way Java manages memory,
it’s possible to get memory consistency errors when multiple threads can read and write the same variable.

Java’s memory management model is outside the scope here. All we need to know is that each thread has a CPU cache,
which can contain copies of values that are in main memory.

Since it’s faster to read from the cache, this can improve the performance of an application.
There would not be a problem if there was only one CPU, but these days, most computers have more than one CPU.

When running an application, each thread may be running on a different CPU, and each CPU has its own cache.
It’s possible for the values in the caches to become out of synch with each other,
and with the value in main memory - a memory consistency error.

Suppose we have two threads that use the same int counter. Thread1 reads and writes the counter. Thread2 only reads the counter.
As we know, reading and writing to an int is an atomic action. A thread won’t be suspended in the middle of reading or writing
the value to memory. But let’s suppose that Thread1 is running on CPU1, and Thread2 is running on CPU2. Because of CPU caching,
the following can happen:

1. The value of the counter is 0 in main memory.
2. Thread1 reads the value of 0 from main memory.
3. Thread1 adds 1 to the value.
4. Thread1 writes the value of 1 to its CPU cache.
5. Thread2 reads the value of counter from main memory and gets 0, rather than the latest value, which is 1.

This is where volatile variables come in. When we use a non-volatile variable the JVM doesn’t guarantee
when it writes an updated value back to main memory. But when we use a volatile variable, the JVM writes the value
back to main memory immediately after a thread updates the value in its CPU cache.
It also guarantees that every time a variable reads from a volatile variable, it will get the latest value.

To make a variable volatile, we use the volatile keyword.
// public volatile int counter;

A thread can be suspended between any of these steps. As a result, the following could happen:

1. Thread1 reads the value of counter and gets 5.
2. Thread1 suspends.
3. Thread2 reads the value of counter and get 5. It adds 1 to the value and writes 6 to counter, then suspends.
4. Thread3 reads the value of counter and get 6. It adds 1 to the value and writes 7 to counter, then suspends.
5. Thread1 runs again. It adds 1 to the value of 5 and writes 6 to counter.
6. Oops.
